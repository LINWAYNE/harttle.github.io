---
layout: blog
categories: reading
title: IEC 61131-3（PLC）学习笔记
tags: PLC
redirect_from:
  - /reading/plc.html
  - /2014/07/23/plc/
---

IEC 61131-3 规定了可编程控制器编程语言的 *语法* 和 *语义* 。这一套统一的编程语言分如下两类：

1. 两种文本语言。 *IL (Instruction List)* 和 *ST (Structured Text)*
2. 两种图形语言。 *LD (Ladder Diagram)* 和 *FBD (Function Block Diagram)*

> *顺序功能图(SFC)元素* 用来结构化描述可编程控制器程序和功能块的内部组织。
> *配置元素* 用来支持将可编程控制器程序安装到可编程控制器系统中。

*符合* IEC 61131-3 的可编程控制器程序应满足如下要求：

1. 对于特定的语言，只使用该标准规定的特性。
2. 不使用语言的扩展特性。
3. 不依赖于对 **实现相关** 的任何特别解释。

<!--more-->

# 概述

## 定义

**聚集** ：数据对象结构化的收集所形成的数据类型。

**赋值** ：给定变量或 *聚集* 值的机制。

**数据类型** ：取值的集合以及允许的操作集合。

**声明** ：建立 *语言元素* 定义的机制。

**分隔符** ：用来分隔程序语言元素的字符或字符的组合。

**求值** ：在程序执行期间，为表达式、功能、网络或功能块的输出确定值的过程。

**直接量** ：直接表示一个值的词法单元。

**保持的数据** ：以某种方式存储，在经过断电/通电序列后，能保持值不变的数据。

**语义** ：编程语言的符号元素之间的关系，它们的含义、解释以及使用。

## 软件模型

在可编程控制器软件模型中， **配置** 是对应于可编程控制器系统的语言元素， **资源** 则对应于信号处理功能及其人机接口、传感器-执行器接口（如果有的话）。

一个 *配置* 包含一个或更多的 *资源* ，每个 *资源* 包含一个或更多的 *程序* 。而程序的运行受零个或更多 *任务* 的控制， *程序* 可能包含零个或更多 *功能块* 或其他语言元素。

![](/assets/img/blog/software-model.png)

## 通信模型

1. 在同一程序内，通过直接将一个程序元素的输出连接到另一个程序元素的输入，完成变量间的通信。
2. 在同一配置中的程序之间，变量的值可以通过全局变量来通信。
3. 使用通信功能块，变量的值可以在同一程序的不同部分之间、同一或不同配置的不同程序之间、可编程控制器程序和非可编程控制器系统之间进行通信。
4. 此外，可编程控制器或非可编程控制器系统间通过 *访问路径* 传输数据。


## 程序设计模型

可编程控制器编程语言元素有如下的分类：

* 数据类型和变量
* 程序组织单元：功能、功能块、程序
* 顺序功能图（SFC）元素
* 配置元素：全局变量、资源、任务、访问路径

这些元素的组合应遵守下列规则：

1. 导出数据类型的声明可以使用标准数据类型（包括基本数据类型和一般数据类型）、先前导出的任何数据类型。
2. 导出功能的声明可以使用标准或导出数据类型、标准功能、先前导出的任何功能。该声明可以使用 IL,ST,LD,FBD 语言。
3. 导出功能块的声明可以使用标准或导出数据类型和功能、标准功能块、先前导出的任何功能块。该声明可以使用 IL,ST,LD,FBD语言和SFC元素。
4. 程序声明可以使用标准或导出数据类型、功能和功能块。该声明可以使用IL,ST,LD,FBD语言和SFC元素。
5. 通过配置元素，可以将程序组合形成配置。

![](/assets/img/blog/programming-model.png)

# 共同元素

## 字符的使用

文本/图形语言 **字符集** 定义在 ISO-646IRV中，同时有其他字符集的扩展，如 ISO 10646-1 定义的“拉丁-1 补充”。

**标识符** 是由字母、数字、下划线组成的字符串，并且由字母或下划线开始。

* 可编程控制器编程语言是大小写不敏感的。
* 标识符中的下划线是有意义的，然而多个连续的下划线是不允许的。
* 标识符至少应支持6个字符。

**注释** 是在程序中引入文本的语言构造，并且对程序的执行没有影响。在可编程控制器语言中，注释的分隔符为`(*` 和 `*)`。

> 嵌套的注释将被当做 **错误** 。

**编译指示** 是在程序组织单元中引入文本的语言构造，并且可能会对程序执行前的准备产生影响。在可编程控制器语言中，编译指示的分隔符为`{` 和 `}`。

## 数据的外部表示

### 数字直接量

有两种数字直接量：整数和实数。数字直接量定义为十进制数或其他基底的数。

> 在数字直接量中，插在数字间的单个 `_` 是没有意义的，其他下划线的使用都是不允许的。

示例：

```
-12 0 123_456 +986
-12.0 0.0 0.4560 3.14159_26
-1.34E-12 or -1.34e-12
16#FF or 16#ff (十进制255)
FALSE TRUE
UINT#16#9AF DINT#5
```

### 字符串直接量

字符串直接量包括单字节和双字节编码的字符。

**单字符** 字符串以`'`分隔，`$`与随后的两位16进制数表示8位字符码。 **双字节** 字符串以`"`分隔，`$`与随后的4四位16进制数表示16位字符码。`$`与随后的一个字符表示转移。

示例：

```
''  'A' '$''    'Ä Ë' == '$C4$CB'
""  "A" "$""    "Ä Ë" == "$00C4$00CB"
STRING#'OK' == WSTRING#'OK'
```

转义列表

组合     |   解释
---             |   ---
`$$`            |   美元符号
`$'`/`$"`    |   引号
`$L`/`$l`    |   换行
`$N`/`$n`    |   新行 
`$P`/`$p`    |   换页
`$R`/`$r`    |   回车
`$T`/`$t`    |   制表符

### 时间直接量

有两类的时间直接量：

1. **持续时间** 来度量或控制一个控制事件消耗的时间。
2. **时间点** （可以包括日期）来同步控制事件的开始或结束。

* 可选的单个`_`可以用来分隔不同的时间单位。
* 持续时间的最大单位允许“溢出。
* 最小单位可以是不含指数的实数。

关键字    |   持续时间    |   时间点
---         |   ---         |   ---
全拼        | `TIME`        |   `DATE` `TIME_OF_DAY` `DATE_AND_TIME`
简写        |   `T`         |   `D` `TOD` `DT`

示例：

```
T#14.7h t#5d14h12m18s3.5ms  TIME#-14ms
DATE#1984-06-25 tod#15:36:55.36
date_and_time#1984-06-25-15:36:55.36
```

## 数据类型

### 基本数据类型

编号 | 关键字 | 数据类型 |  长度
--- |   ---     |   ---     |   ---
1 | `BOOL` | 布尔 | 1 
2 | `SINT` | 短整数 | 8
3 | `INT` | 整数 | 16 
4 | `DINT` | 双精度整数 | 32
5 | `LINT` | 长整数 | 64
6 | `USINT` | 无符号短整数 | 8
7 | `UINT` | 无符号整数 | 16
8 | `UDINT` | 无符号双精度整数 | 32
9 | `ULINT` | 无符号长整数 | 64
10 | `REAL` | 实数 | 32
11 | `LREAL` | 长实数 | 64
12 | `TIME` | 持续时间 | --
13 | `DATE` | 如期 | --
14 | `TIME_OF_DAY`/`TOD` | 时间（当日） | --
15 | `DATE_AND_TIME`/`DT` | 时间与日期 | --
16 | `STRING` | 可变长度单字节字符串 | 8 
17 | `WSTRING` | 可变长度双字节字符串 | 16 
18 | `BYTE` | 长为8的位串 | 8 
19 | `WORD` | 长为16的位串 | 16 
20 | `DWORD` | 长为32的位串 | 32 
21 | `LWORD` | 长为64的位串 | 64 

### 一般数据类型

在功能和功能块的输入/输出说明中，除 *基本数据类型* 外，还可以使用 **一般数据类型层级** 。一般数据类型用前缀`ANY`标识。其层级关系如下：

```
ANY
    ANY_DERIVED
    ANY_ELEMENTARY
        ANY_MAGNITUDE
            ANY_NUM
                ANY_REAL 
                    LREAL
                    REAL 
                ANY_INT
                    LINT, DINT, INT, SINT
                    ULINT, UDINT, UINT, USINT 
            TIME
        ANY_BIT
            LWORD, DWORD, WORD, BYTE, BOOL
        ANY_STRING 
            STRING
            WSTRING 
        ANY_DATE
            DATE_AND_TIME 
            DATE, TIME_OF_DAY
```

### 导出数据类型

**导出数据类型** 使用`TYPE...END_TYPE`声明。例如，从基本数据类型直接导出的数据类型：`TYPE RU_REAL : REAL ; END_TYPE`.

#### 枚举

```
TYPE ANALOG_SIGNAL_TYPE : 
    (SINGLE_ENDED, DIFFERENTIAL) := SINGLE_ENDED ; 
END_TYPE
```

在 **枚举** 中，可以使用类型前缀（如`ANALOG_SIGNAL_TYPE#`）可用来避免歧义。如果没有提供足够的类型信息，将被视为 **错误** 。

**枚举** 类型的默认初始值为第一个标识符，或用户在类型声明中使用`:=`指定的值。

#### 子域

```
TYPE ANALOG_DATA : INT (-4095..4095) ; END_TYPE
```

**子域** 声明指定了数据取值的上限和下限。如果子范围类型的值超出了其规定的范围，将被视为 **错误** 。

*子域* 数据类型的初始值为取值的下限。

#### 结构

```
TYPE 
    ANALOG_CHANNEL_CONFIGURATION :
        STRUCT
            RANGE : ANALOG_SIGNAL_RANGE ; 
            MIN_SCALE : ANALOG_DATA ; 
            MAX_SCALE : ANALOG_DATA ;
        END_STRUCT ; 
    ANALOG_16_INPUT_CONFIGURATION :
        STRUCT
            SIGNAL_TYPE : ANALOG_SIGNAL_TYPE ;
            FILTER_PARAMETER : SINT (0..99) ;
            CHANNEL : ARRAY [1..16] OF ANALOG_CHANNEL_CONFIGURATION ;
        END_STRUCT ; 
END_TYPE
```

对于 *结构* 和 *数组* ，初始值对应基本数据类型的初始值，除非用户使用`:=`指定。

> 基本数据类型的初始值均为0，日期除外：`0000-00-01`。

#### 数组

```
TYPE ANALOG_16_INPUT_DATA : 
    ARRAY [1..16] OF ANALOG_DATA ; 
END_TYPE
```

`STRING` 和 `WSTRING` 的默认长度是 **实现相关** 的，但用户可以指定，例如：`TYPE STR10 : STRING[10] := 'ABCDEF'; END_TYPE`。


## 变量

### 表示

#### 单元素变量

**单元素变量** 定义为表示单个基本数据类型数据元素的变量。这部分定义了变量的 **符号表示** 和 **直接表示** （数据元素与可编程控制器输入/输出/存储器结构的物理/逻辑地址的关联）。

*单元素变量* 的 *直接表示* 由一个`%`，一个 *地址前缀* ，一个 *大小前缀* ，和一个或更多由`.`分隔的无符号整数组成。

> `*`可用于地址前缀，表示 *直接表示* 还没有完全指定。变量地址应在 *配置* 的`VAR_CONFIG...END_VAR` 构造内完全指定，否则将产生 **错误** 。

位置前缀 | 含义   | 地址前缀           | 含义
---             |   ---     |   ---                 |   ---
I               | 输入     | X/None                | 单个位
Q               | 输出    | B                     | 字节 (8位)
M               | 存储器    | W                     | 字 (16位)
*               | 未指定 | D             | 双字 (32位)
                |           | L                     | 长字 (64位)

示例

```
%QX75 or %Q75   (* 输出的75位 *)
%IW2.5.7.1      (* 在输入的物理/逻辑层级2.5.7.1的字 *)
```

> 一个可编程控制器通过分级寻址访问另一个控制器的数据应被视为 *语言扩展* 。最大级数是 **实现相关** 的。

#### 多元素变量

在本标准中定义的 **多元素变量** 包括 *数组* 和 *结构* 。

**数组** 是包含有着同样属性的数据对象的 *聚集* ，每个数据对象可通过下标来引用。

**结构** 是命名数据元素收集而成的数据类型。

示例

```
OUTARY[%MB6,SYM] := INARY[0] + INARY[7] - INARY[%MB6] * %IW62 ;
MODULE_5_CONFIG.SIGNAL_TYPE := SINGLE_ENDED; 
MODULE_5_CONFIG.CHANNEL[5].RANGE := BIPOLAR_10V;
```

### 初始化

当配置元素（资源、配置）启动时，每个与该元素关联的变量可以取如下的初始值：

* 上次停机时该变量的值（保持的值）。
* 用户指定的初始值。
* 该变量关联的数据类型的默认初始值。

> 用户可通过`RETAIN`限定符来指定变量是保持的。

### 声明

文本形式的变量声明使用关键字`VAR`（或其他`VAR`关键字），接着一个可选的限定符，接着一个或更多的用`;`分隔的声明，以关键字`END_VAR`结束。

变量声明涉及的关键字

| 关键字       |   变量使用  |
| ---           |   ---             |
| `VAR`         | 内部变量，组织单元内使用 |
| `VAR_INPUT`   | 外部提供，组织单元内只读 |
| `VAR_OUTPUT`  | 组织单元提供，外部实体使用 |
| `VAR_IN_OUT`  | 外部实体提供，组织单元内可读写 |
| `VAR_EXTERNAL`| 配置通过`VAR_GLOBAL`提供，组织单元内可读写 |
| `VAR_GLOBAL`  | 全局变量声明 |
| `VAR_ACCESS`  | 访问路径声明 |
| `VAR_TEMP`    | 功能块和程序内的临时存储 |
| `VAR_CONFIG`  | 实例初始化和地址赋值 |
| `RETAIN`     | 保持的变量 |
| `NON_RETAIN` | 非保持的变量 |
| `CONSTANT`   | 常数（只读变量） |
| `AT`          | 地址赋值 |

在 *功能块* 和 *程序* 里，以`VAR_TEMP...END_VAR`构造声明的变量在每次 *实例调用* 都会初始化。

变量声明的作用域对于所在的程序组织单元是 *局部的* 。`VAR_GLOBAL...END_VAR`变量只有通过`VAR_EXTERNAL`声明后才是可访问的，且`VAR_EXTERNAL`中的类型声明与对应的`VAR_GLOBAL`应保持一致，否则将产生 **错误** 。

#### 类型赋值

物理/逻辑地址到符号表示变量的赋值应使用`AT`关键字。如果没有这样的赋值，变量将被自动分配到可编程控制器存储器中合适的地址。

示例

```
VAR RETAIN
    AT %IW6.2 : WORD;       
    LIM_SW_S5 AT %IX27 : BOOL;
    INARY AT %IW6 : ARRAY [0..9] OF INT;
    THREE : ARRAY[1..5,1..10,1..8] OF INT;
END_VAR
```

#### 赋初始值

初始值可以通过使用`VAR_CONFIG...END_VAR`构造提供的实例初始化特性来完成。实例初始化提供的初始值总是应当覆盖类型提供的初始值。

> 在`VAR_EXTERNAL`声明中不允许给定初始值。

示例

变量初始化

```
VAR
    VALVE_POS AT %QW28 : INT := 100;
    OUTARY AT %QW6 : ARRAY[0..9] OF INT := [10(1)];
    OKAY : STRING[10] := 'OK';
    TBT : ARRAY [1..2,1..3] OF INT := [1,2,3(4),6] ;
END_VAR
```

结构

```
(* 结构声明 *)
TYPE 
    ANALOG_CHANNEL_CONFIGURATION :
        STRUCT
            RANGE : ANALOG_SIGNAL_RANGE ; 
            MIN_SCALE : ANALOG_DATA ; 
            MAX_SCALE : ANALOG_DATA ;
        END_STRUCT ; 
    ANALOG_16_INPUT_CONFIGURATION :
        STRUCT
            SIGNAL_TYPE : ANALOG_SIGNAL_TYPE ;
            FILTER_PARAMETER : SINT (0..99) ;
            CHANNEL : ARRAY [1..16] OF ANALOG_CHANNEL_CONFIGURATION ;
        END_STRUCT ; 
END_TYPE

(* 结构初始化 *)
VAR MODULE_8_CONFIG: 
    ANALOG_16_INPUT_CONFIGURATION := (
        SIGNAL_TYPE := DIFFERENTIAL, 
        CHANNEL := [
            4(
                (RANGE := UNIPOLAR_1_5V)
            ), 
            (
                RANGE:= BIPOLAR_10_V,
                MIN_SCALE := 0, 
                MAX_SCALE := 500
            )
        ]
    );
END_VAR
```

功能块初始化

```
VAR TempLoop : 
    PID := (
        PropBand := 2.5, 
        Integral := T#5s
    );
END_VAR
```

## 程序组织单元

IEC 61131-3 定义的 **程序组织单元** 包括：功能、功能块、程序。这些程序组织单元不应是 *递归* 的，即对一个程序组织单元的调用不会再次引发对该类型程序组织单元的调用。

### 功能

**功能** ：执行后产生一个结果数据元素，和任意数量的输出元素的程序组织单元。

> 功能结果可以是多值的，即数组或结构。功能不能包含状态信息，即每次同样参数的调用应得到同样的结果。已声明的功能可以在其他程序组织单元中调用。

功能使用示例-ST语言：

```
VAR X,Y,Z,RES1,RES2 : REAL; EN1,V : BOOL; END_VAR

RES1 := DIV(IN1 := COS(X), IN2 := SIN(Y), ENO => EN1); 
RES2 := MUL (SIN(X), COS(Y));

Z: = ADD(EN := EN1, IN1 := RES1, IN2 := RES2, ENO => V);
```

功能使用示例-FBD语言：

```
       +-----+      +------+     +------+
X ---+-| COS |--+  -|EN ENO|-----|EN ENO|--- V
     | |     |  |   |      |     |      |
     | +-----+  +---| DIV  |-----| ADD  |--- Z
     |              |      |     |      |
     | +-----+      |      |   +-|      |
Y -+---| SIN |------|      |   | +------+
   | | |     |      +------+   |
   | | +-----+                 |
   | |                         | 
   | | +-----+      +------+   |
   | +-| SIN |--+  -|EN ENO|-  | 
   |   |     |  |   |      |   |
   |   +-----+  +- -| MUL  |---+
   |                |      |
   |   +-----+      |      | 
   +---| COS |------|      | 
       |     |      +------+
       +-----+
```

#### 表示法

* 对 `VAR_OUTPUT` 的赋值可以空白，也可以用变量。
* 对 `VAR_IN_OUT` 参数的赋值应该是变量。
* 对 `VAR_INPUT` 的赋值可以为空白、常量、变量和功能调用。对于后者，功能的结果将被作为实参。
* 在图形语言中，功能应表示为矩形块，大小取决于输入参数等信息的多少。功能名应卸载矩形块内部。每个输入输出都用一根线来表示。
* 对于输入输出变量名的规定：
    * 没有指定输入变量名时，默认名为：`IN1`, `IN2`（从上到下顺序）
    * 只有一个未命名输入时，默认名为：`IN`
    * 上述默认名可以出现在功能表示的左边，也可以不出现。
* 还可以使用附加输入 `EN` 和附加输出 `ENO`，它们分别位于左右的最上方。
* 应使用信号线进行参数的连接（包括功能结果）。
* 布尔类型的输入输出可用 `O` 进行翻转。
* `VAR_IN_OUT` 应被适当地连接。
* 参数列表是一系列实参到形参的赋值组成的集合。
    * `VAR_IN` `VAR_IN_OUT` 赋值使用 `:=`
    * `VAR_OUT` 赋值使用 `=>`
* 除`EN` `ENO`外，参数列表中参数的数目、类型和顺序都应与功能定义相符。

#### 执行控制

附加的 `EN`(Enable) 输入、`ENO`(Enable Out) 输出可用于控制功能的执行，规则如下：

1. 如果 `EN` 值为 `FALSE`，功能被调用时不应执行，且 `ENO` 应被PC系统重置为 `FALSE`。否则功能应被执行，且 `ENO` 应被PC系统置为 `TRUE`，功能操作中也可以对`ENO`进行赋值。
2. 当功能执行中发生错误时，`ENO` 应被PC系统置为 `FALSE`，否则制造商应提供的其他的错误处理方式。
3. 当`ENO`值为`FALSE`时，功能所有输出的值均 **实现相关** 。

`EN` `ENO` 使用示例：

```
(* LD语言 *)
         +-------+         |
| ADD_EN |   +   | ADD_OK  |
+---||---|EN  ENO|---( )---+ 
|        |       |         |
|    A---|       |---C     |
|    B---|       |         | 
         +-------+         |

(* FBD语言 *)
         +-----+ 
ADD_EN---|EN   |
     A---|  +  |---C 
     B---|     |
         +-----+

```

#### 声明

文本语言中，功能声明由以下几部分组成：

1. 关键字 `FUNCTION`；
2. `VAR_INPUT...END_VAR` 构造，规定输入变量；
4. `VAR_IN_OUT...END_VAR`构造和`VAR_OUTPUT...END_VAR`构造，分别规定输入-输出和输出变量。
3. `VAR...END_VAR` 构造，规定内部变量；
5. 功能体。规定功能对这些变量的操作，通过对与功能同名的变量赋值来设置返回值。
6. 终止关键字 `END_FUNCTION`

图形语言中，功能声明由以下几部分组成：

1. 关键字 `FUNCTION` `END_FUNCTION`，或等效的图形元素；
2. 功能名，功能结果和功能变量的名称、类型、初始值的图形说明；
3. 内部变量的名称、类型、初始值的图形说明。
4. 功能体，同上。

> 每个 *资源* 中的功能声明数目是一个 **实现相关** 的参数。

功能声明示例-ST语言：

```
FUNCTION SIMPLE_FUN : REAL 
    (* External interface specification *) 
    VAR_INPUT
        A,B : REAL ; 
        C   : REAL := 1.0;
    END_VAR
    VAR_IN_OUT COUNT : INT ; END_VAR 
    VAR COUNTP1 : INT ; END_VAR

    (*Function body specification *) 
    COUNTP1 := ADD(COUNT,1); 
    COUNT   := COUNTP1 ;
        SIMPLE_FUN := A*B/C; 
END_FUNCTION
```

功能声明示例-FBD语言：

```
FUNCTION
        +-------------+ (* External interface specification *)
        | SIMPLE_FUN  | 
REAL----|A            |----REAL
REAL----|B            | 
REAL----|C            | 
INT-----|COUNT---COUNT|----INT
        +-------------+
(* Function body specification *)
       +---+
       |ADD|---         +----+ 
COUNT--|   |---COUNTP1--| := |---COUNT
    1--|   |            +----+
       +---+    +---+
            A---| * |   +---+
            B---|   |---| / |---SIMPLE_FUN
                +---+   |   | 
            C-----------|   | 
                        +---+
END_FUNCTION
```

#### 重载、类型化、类型转换

**重载** ：标准功能、功能块、操作或指令可以通过 *一般数据类型* 标识符操作多种类型的输入。可编程控制器系统支持某个标准功能、功能块、操作符、指令的重载时，应对其给定的一般数据类型可接受的基本数据类型都给与支持。

**类型化** ：即在重载功能名后添加`_`和类型名。此时，该功能的输入/输出将被限制为该类型。

> 例如，采用一般数据类型`ANY_NUM`的功能可操作的数据类型包括：`LREAL`,`REAL`,`DINT`,`INT`,`SINT`。
> 
> 在功能重载中，同样的一般数据类型参数应当具有相同的实际类型。如果需要，类型转换会被执行以满足该要求。

重载功能

```
            +-----+
            | ADD | 
ANY_NUM-----|     |----ANY_NUM
ANY_NUM-----|     |
     . -----|     |
     . -----|     |
ANY_NUM-----|     | 
            +-----+
```

类型化功能

```
        +---------+
        | ADD_INT | 
INT-----|         |----INT
INT-----|         | 
 . -----|         | 
 . -----|         |
INT-----|         |
        +---------+
```

类型转换

```
    +-----------+   +---+ 
A---|INT_TO_REAL|---| + |---C 
    +-----------+   |   |
B-------------------|   | 
                    +---+
C := INT_TO_REAL(A)+B;
```

#### 标准功能

这一章对所有可编程控制器编程语言通用的功能进行了定义。包括一些 *可扩展* 的标准功能，它们可以对两个或者更多的输入进行指定的操作。

> 最大的输入数目则是 **实现相关** 的。对于指定形参方式的功能调用，最后位置的形参名将决定实际的输入数目。

示例：

```
X := ADD(Y1,Y2,Y3);
(* 相当于： *)
X := ADD(IN1 := Y1, IN2 := Y2, IN3 := Y3);

I := MUX_INT(K:=3,IN0 := 1, IN2 := 2, IN4 := 3);
(* 相当于： *)
I := 0;
```

标准功能包括：

1. 类型转换功能。`*_TO_**`,`TRUNC`(截断),`*_BCD_TO_**`,`**_TO_BCD_*`，`*`可以是字符类型，`**`可以是整型。
2. 数值功能。`ABS`,`SQRT`,`LN`,`LOG`,`EXP`,`SIN`,`COS`,`TAN`,`ASIN`,`ACOS`,`ATAN`,`+`,`*`,`-`,`/`,`modulo`,`**`,`:=`
3. 位串功能。`SHL`,`SHR`左右移位；`ROR`,`ROL`左右旋转。
4. 选择和比较功能。
    * 选择功能：`SEL(G:=0,IN0:=X,IN1:=5)`,`MAX`,`MIN`,`MUX`.
    * 比较功能：`>`,`<`,`>=`,`<=`,`=`,`<>`.
    * 布尔运算：`&`,`XOR`,`OR`,`NOT`.
5. 字符串功能。`LEN`,`LEFT`,`RIGHT`,`MID`,`CONCAT`,`INSERT`,`DELETE`,`REPLACE`,`FIND`.
6. 时间功能。`+`,`-`,`*`,`/`,`DT_TO_TOD`,`DT_TO_DATE`.
7. 枚举功能。`SEL`,`MUX`,`=`,`<>`

### 功能块

**功能块** ：执行后产生一个或多个值的程序组织单元。 *功能块* 可创建多个 *实例* ，每个实例拥有对应的标识符（即实例名）与相应的数据结构来保存输出变量、内部变量、输入变量（在某些实现中，只保存输入变量的引用）。

> 输出变量和必要的内部变量在执行后将被保存，于是同样参数的调用可能产生不同的结果。在功能块实例外部，只有输入变量和输出变量是可访问的。

#### 表示法

在文本语言中， *功能块的实例* 可使用`VAR...END_VAR`声明，与 *结构体* 实例的声明相同。

在图形语言中， *功能块的实例* 采用矩形块表示，功能块类型名位于块内部，实例名位于块上方，其他规则同 *功能的图形表示* 。

功能块实例使用示例：

```
(* 图形方式，FBD语言 *)
         FF75 
       +------+
       |  SR  | 
%IX1---|S1  Q1|---%QX3
%IX2---|R     | 
       +------+

(* 文本方式，ST语言 *)
VAR FF75: SR; END_VAR (* 声明 *) 
FF75(S1:=%IX1, R:=%IX2); (* 调用 *) 
%QX3 := FF75.Q1 ; (* 输出赋值 *)
```

功能块变量的读写属性：

* 输入变量在功能块内部是只读的，外部是只写的（或通过通信功能等进行读写，见 IEC 61131-1）。
* 输出变量在功能块内部是读写的，外部是只读的。
* 输入-输出变量在内外都是可读写的。

> 未赋值（或未连接）的输入变量将保持他们的初始值或上次调用（假如曾被调用过）时的值。

对于`EN`,`ENO`在功能块中的用法有如下规则：

1. 当`EN`为`FALSE`时，输入变量是否进行赋值是 **实现相关** 的，同时功能块体不应被执行，且`ENO`应被PC系统设为`FALSE`；否则，功能块将被执行且`ENO`应被PC系统赋为`TRUE`，功能块操作中也可以对`ENO`进行赋值。
2. 当`ENO`为`FALSE`时，功能块的输出变量`VAR_OUTPUT`应保持上次调用的值。


#### 声明

如同 *功能声明* ， *功能块声明* 也可采用文本方式和图形方式，他们之间的区别如下：

1. 功能块的界定关键字为：`FUNCTION_BLOCK`,`END_FUNCTION_BLOCK`；
2. `RETAIN`可用作内部变量和输出变量的限定符；
3. 以`VAR_EXTERNAL`构造传入的变量是可修改的；
4. 以`VAR_INPUT`,`VAR_IN_OUT`,`VAR_EXTERNAL`传入的功能块实例的输出变量是只读的。
5. 以`VAR_IN_OUT`,`VAR_EXTERNAL`传入的功能块实例可以被调用；
6. 在文本方式的声明中，`R_EDGE`,`F_EDGE`限定符将引发对`R_TRIG`,`F_TRIG`功能块实例的隐式声明，该限定符提供边沿检测功能；
7. 边沿检测的图形表示中，用`>`,`<`作为输入变量与功能块的交点；
8. 一般数据类型的使用与实际类型的推导与 *功能声明* 相同，对于这类功能块在调用时应显式地进行输出赋值（`=>`）；
9. `*`可用于内部变量声明。
10. 下列情况中的未赋值将产生 **错误** ：
    * 输入-输出变量
    * 功能块类型的输入变量

> 变量和功能块实例可通过`VAR_IN_OUT`传入功能块，而功能/功能块的输出却不可以。这是为了避免不小心对他们进行的修改。

功能块声明-ST语言

```
FUNCTION_BLOCK DEBOUNCE 
(* 外部接口 *) 
VAR_INPUT IN : BOOL ;   (* 初始值 = 0 *)
    DB_TIME : TIME := t#10ms ; (* 初始值 = t#10ms *)
END_VAR
VAR_OUTPUT OUT : BOOL ; (* 初始值 = 0 *) 
    ET_OFF : TIME ;     (* 初始值 = t#0s *)
END_VAR
VAR DB_ON : TON ;       (* 内部变量 *) 
    DB_OFF : TON        (* 功能块实例 *);
    DB_FF : SR ; 
END_VAR

(* 功能块体 *) 
DB_ON(IN := IN, PT := DB_TIME) ;
DB_OFF(IN := NOT IN, PT:=DB_TIME) ; 
DB_FF(S1 :=DB_ON.Q, R := DB_OFF.Q) ; 
OUT := DB_FF.Q ;
ET_OFF := DB_OFF.ET ;

END_FUNCTION_BLOCK
```

功能块声明-FBD语言

```
FUNCTION_BLOCK
(* 外部接口 *)
       +---------------+
       |    DEBOUNCE   | 
BOOL---|IN          OUT|---BOOL 
TIME---|DB_TIME  ET_OFF|---TIME 
       +---------------+

(* 功能体 *)
              DB_ON       DB_FF 
             +-----+     +----+ 
             |TON  |     | SR |
IN----+------|IN  Q|-----|S1 Q|---OUT 
      |  +---|PT ET|  +--|R   |
      |  |   +-----+  |  +----+
      |  |            |
      |  |    DB_OFF  |
      |  |   +-----+  | 
      |  |   |TON  |  |
      +--|--O|IN  Q|--+
DB_TIME--+---|PT ET|--------------ET_OFF 
             +-----+
END_FUNCTION_BLOCK
```

#### 标准功能块

这一章对所有可编程控制器编程语言通用的功能块进行了定义。有些是重载过的，有些具有 *可扩展* 的输入输出。

标准功能块包括：

1. 双稳态。包括置位主导的和复位主导的两种。
2. 边沿检测。包括上升沿检测和下降沿检测两种。
3. 计数器。包括升计数器、降计数器、升降计数器。
4. 定时器。包括脉冲定时器、接通延时定时器、断开延时定时器。
5. 通信功能块。标准通信功能块在 IEC 61131-5 定义，包括：设备检验、轮询数据获取、程控数据获取、参数控制、互锁控制、程控报警、连接管理和保护。

### 程序

**程序** ：为实现机械控制或PC系统过程需要的信号处理，必要的编程语言元素和构造组成的逻辑组合体。

程序的声明和使用与功能块基本相同，附加的特性和区别如下：

1. 分隔关键字为`PROGRAM...END_PROGRAM`
2. 程序可以包含访问路径的定义：`VAR_ACCESS...END_VAR`，提供了命名变量用于通信服务（IEC 61131-5）。
2. 可以包含全局变量定义：`VAR_GLOBAL...END_VAR`。
2. 可以包含外部变量声明：`VAR_EXTERNAL`。
2. 可以包含临时变量定义：`VAR_TEMP`。
3. *程序* 只能在 *资源* 中实例化，而 *功能块* 只能在 *程序* 或其他 *功能块* 中实例化。
4. 程序的全局和内部变量声明中可以包含地址赋值，而不完整的直接表示的地址赋值只能用于内部变量。


## 顺序功能图（SFC）元素

### 概述

**顺序功能图** 用于结构化描述PC程序组织单元的内部组织，它使用本标准定义的语言之一，用于执行 *顺序控制* 功能。

SFC将PC程序组织单元划分为一系列的 *步* 和 *转换* ，它们之间用 *有向连接* 连起来。每个 *步* 与一组 *动作* 关联，每个 *转换* 与一个 *转换条件* 关联。

如果一个程序组织单元的任何部分被划分为SFC元素，那么整个程序组织单元都应进行划分。如果一个程序组织单元没有划分，那么整个程序组织单元可被视为单个 *动作* 。

> SFC要求保存状态信息，故可以描述的程序组织单元只有 *功能块* 和 *程序* 。

### 步

**步** 表示程序组织单元的状态，该状态描述了程序组织单元对于输入输出的行为特性。这些行为规则由其关联的 **动作** 定义。

*步* 在图形语言中，表示为包含步名称的块；在文本语言中表示为`STEP...END_STEP`构造。 *有向连接* 表示为步上方的垂直线，或使用文本表示为`TRANSITION...END_TRANSITION`构造。

**步运行时间** （指从初始化开始）用`***.T`表示。当步被置为不活动时，步运行时间置为不活动的时间；当步被激活时，步运行时间被置为`T#0s`。

**步的状态** 可以是激活的或未激活的，文本语言中用`***.X`表示，图形语言中用块右侧的连线表示。

**程序组织单元的状态** 由激活的 *步* 和内部、输出变量的值定义。其初始状态表示为 **初始步** （初始为激活状态的步）、内部和输出变量的初始值。每个 *SFC网络* 都有且只有一个初始步。初始步表示为双线边缘的块。

> 步名、步状态、步运行时间的名称的作用域对于其所在的程序组织单元是局部的。
> 每个SFC图可以拥有的 *步* 数上限和 *步运行时间* 的精度是 **实现相关** 的。

图形语言

```
   | 
+-----+
| *** |     (* 步 *)
+-----+
   |
    |
+=======+ 
|| *** || 
||     ||   (* 初始步 *)
+=======+
    |
```

文本语言 

```
(* 步 *)
STEP *** :  
    (* Step body *)
END_STEP

(* 初始步 *)
INITIAL_STEP *** :  
    (* Step body *) 
END_STEP
```

### 转换

**转换** 表示了控制从前面的一个或多个 *步* 沿着相应的 *有向连接* 转移到后面的一个或多个 *步* 。 *转换* 表示为与表示 *有向连接* 的垂直线相交的水平线。

与 *转换* 相关联的 *转换条件* 有如下表示方法：

1. *有向连接* 旁放一个ST语言的布尔表达式。
2. *有向连接* 旁放一个LD语言的网络。
3. *有向连接* 旁放一个FBD语言的网络。
4. 放一个LD或FBD语言的网络，使其输出与 *有向连接* 通过 *连接器* 相交。
5. 在ST语言中，使用`TRANSITION...END_TRANSITION`构造，应包含
    * `TRANSITION FROM`（前面的 *步* ）
    * `TO`（后面的 *步* ）
    * `:=`（指定转换条件）。
6. 在IL语言中，使用`TRANSITION...END_TRANSITION`构造，应包含
    * `TRANSITION FROM`（前面的 *步* ）、
    * `TO`（后面的 *步* ）
    * 另起一行的指令列表（用来计算转换条件）
7. 在 *有向连接* 右边放一个 *转换名* ，该标识符应引用一个`TRANSITIN...END_TRANSITINO`构造。

> 转换条件的名称的作用域对于其所在的程序组织单元是局部的。
> 在计算转换条件时如果产生副作用（如对除转换条件的变量赋值）将会被视为 **错误** 。
> 每个SFC图，每个 *步* 可以拥有的 *转换* 数上限是 **实现相关** 的。

示例：

ST布尔表达式

```
   |
+-----+
|STEP7|
+-----+
   |
   + %IX2.4 & %IX2.3
   |
+-----+
|STEP8|
+-----+
   |
```

图形网络

```
(* LD *)             | 
                  +-----+ 
                  |STEP7| 
                  +-----+
| %IX2.4  %IX2.3     | 
+---||-----||--------+ 
|                    |
                  +-----+ 
                  |STEP8| 
                  +-----+
                     |
(* FBD *)              | 
                    +-----+ 
                    |STEP7|
         +-------+  +-----+
         |   &   |     | 
%IX2.4---|       |-----+ 
%IX2.3---|       |     |
         +-------+  +-----+ 
                    |STEP8| 
                    +-----+
                       |
```

连接器

```
              |
           +-----+ 
           |STEP7| 
           +-----+
              | 
>TRANX>-------+ 
              |
           +-----+ 
           |STEP8| 
           +-----+
              |

| %IX2.4  %IX2.3     
+---||-----||----->TRANX>
|                    
```

ST语言

```
STEP STEP7: END_STEP

TRANSITION FROM STEP7 TO STEP8 
    := %IX2.4 & %IX2.3 ;
END_TRANSITION

STEP STEP8: END_STEP
```

IL语言

```
STEP STEP7: END_STEP

TRANSITION FROM STEP7 TO STEP 8: 
    LD %IX2.4
    AND %IX2.3
END_TRANSITION

STEP STEP8: END_STEP
```

LD语言

```
TRANSITION TRAN78 FROM STEP7 TO STEP8:
    |                        | 
    | %IX2.4  %IX2.3  TRAN78 | 
    +---||-----||------( )---+
    |                        |
END_TRANSITION
```

转换名

```
   | 
+-----+ 
|STEP7| 
+-----+
   |
   + TRAN78 
   |
+-----+ 
|STEP8| 
+-----+ 
   |
```

### 动作

每个 *步* 应包含0个或更多的 *动作* 。没有关联动作的步被视为具有`WAIT`功能，等待下一个转换条件变为`TRUE`。

**动作** 可以是：

* 布尔变量
* 一组IL指令
* 一组ST语句
* 一组LD横档
* 一组FBD网络
* SFC图

#### 声明

支持SFC元素的PC实现至少应支持一种以下的动作声明机制。

> *动作* 的作用域对于它的声明所在的程序组织单元是局部的。

LD语言

```
+----------------------------------------+ 
|               ACTION_4                 |
+----------------------------------------+ 
| |  %IX1   %MX3  S8.X  %QX17  |         |
| +---||-----||----||-----()---+         | 
| |                            |         |
| |    +------+                |         |
| +----|EN ENO|         %MX10  |         |
| | C--|  LT  |----------(S)---+         |
| | D--|      |                |         |
| |    +------+                |         |
+----------------------------------------+
```

SFC元素

```
+----------------------------------------+ 
|               OPEN_VALVE_1             |
+----------------------------------------+ 
|          | ...                         |
| +=================+                    |
| || VALVE_1_READY ||                    |
| +=================+                    |
|          |                             | 
|          + STEP8.X                     |
|          |                             |
| +-----------------+  +---+-----------+ | 
| | VALVE_1_OPENING |--| N |VALVE_1_FWD| |
| +-----------------+  +---+-----------+ |
|          | ...                         |
+----------------------------------------+
```

FBD语言

```
+----------------------------------------+ 
|               ACTION_4                 |
+----------------------------------------+
|              +---+                     | 
|        %IX1--| & |                     |
|        %MX3--|   |--%QX17              |
| S8.X---------|   |                     | 
|              +---+    FF28             |
|                      +----+            |
|                      | SR |            | 
|            +------+  | Q1 |-%MX10      | 
|         C--|  LT  |--| S1 |            |
|         D--|      |  +----+            |
|            +------+                    |
+----------------------------------------+
```

ST语言

```
ACTION ACTION_4:
    %QX17 := %IX1 & %MX3 & S8.X ; 
    FF28(S1 := (C<D));
    %MX10 := FF28.Q;
END_ACTION
```

IL语言

```
ACTION ACTION_4: 
    LD S8.X 
    AND %IX1 
    AND %MX3 
    ST %QX17 
    LD C
    LT D
    S1 FF28 
    LD FF28.Q 
    ST %MX10
END_ACTION
```

#### 与步关联

支持SFC元素的PC实现应至少支持一种以下的动作与步的关联机制。

> 每步中的动作上限是 **实现相关** 的。

图形表示

```
  |         (* 动作块 *)
+----+  +-----+----------+---+ 
| S8 |--|  L  | ACTION_1 |DN1|
+----+  |t#10s|          |   |
  |     +-----+----------+---+ 
  + DN1
  |
            
  |         (* 连续的动作块 *)
+----+  +-----+---------------------+---+ 
| S8 |--|  L  |       ACTION_1      |DN1|
+----+  |t#10s|                     |   |
  |     +-----+---------------------+---+ 
  +DN1  |  P  |       ACTION_2      |   |
  |     +-----+---------------------+---+ 
  |     |  N  |       ACTION_3      |   |
  |     +-----+---------------------+---+


            (* 动作块的d字段 *)
    +-----+----------------------+---+ 
----|  N  |      ACTION_4        |   |---
    +-----+----------------------+---+ 
    | %QX17:=%IX1&%MX3&S8.X;         |
    | FF28 (S1 := (C<D));            |
    | %MX10 := FF28.Q;               |
    +--------------------------------+
```

文本表示

```
STEP S8: 
    ACTION_1(L,t#10s,DN1) ; 
    ACTION_2(P) ; 
    ACTION_3(N) ;
END_STEP
```

#### 动作块

**动作块** 是包括一个布尔变量和一个动作限定符的图形元素，用来产生激活条件。

可选的指示符（`c`字段）可以被指定的动作赋值，来表示该动作的完成、超时、错误等。如果没有指定`c`字段，如果`b`字段指定了该动作为布尔变量，则该变量在需要的时候应被解释为`c`字段，如果`b`字段没有指定布尔变量，`c`的值应被视为`FALSE`。

多个 *动作块* 可以在图形中相连，此时有多个指示符变量，但只能有单个共同的布尔输出变量。

除了与 *步* 相关联， *动作块* 也可作为图形元素用于LD或FBD语言。

```
   +-----+--------------+-----+
---| "a" |      "b"     | "c" |--- 
   +-----+--------------+-----+
   | "d"                      |
   |                          | 
   +--------------------------+
```

其中：

* a: 限定符
* b: 动作名
* c: 指示符
* d: 动作，可以采用：IL语言，ST语言，LD语言，FBD语言

动作块在LD/FBD图中使用

```
(* LD *)
|  S8.X  %IX7.5  +---+------+---+  OK1  | 
+--| |----| |----| N | ACT1 |DN1|--( )--+ 
|                +---+------+---+       |

(* FBD *)
         +---+     +---+------+-----+ 
  S8.X---| & |-----| N | ACT1 | DN1 |---OK1
%IX7.5---|   |     +---+------+-----+ 
         +---+
```

#### 动作限定符

每个动作块、步/动作关联都有一个相应的 *动作限定符* ，如下表

限定符  | 解释              | 限定符  | 解释
---     | ---               | ---     | ---
None    | 非存储的          | N       | 非存储的
R       | 重载的复位        | S       | 设置（存储）
L       | 限制时间          | D       | 延迟时间
P       | 脉冲              | SD      | 存储和延迟时间
DS      | 延迟和存储        | SL      | 存储和限制时间
P1      | 脉冲（上升沿）    | P0      | 脉冲（下降沿）

#### 动作控制

动作控制应在功能上等效于下列规则：

1. 每个动作应与一个`ACTION_CONTROL`功能块实例的功能等价体相关联。当动作被声明为布尔变量时，该功能块的输出`Q`即为该变量的状态；当动作被声明为语句或网络时，如果该功能块输出`A`为`TRUE`则应连续地执行，此时动作标志`Q`可以通过功能块实例来只读地访问，实例名即为当前动作名，如`ACTION1.Q`；
2. 如果对`ACTION_CONTROL`的一个布尔输入相应的限定符等效于输入名称（`N`,`R`,`S`,`L`,`D`,`P`,`P0`,`P1`,`SD`,`DS`,`SL`），则称与 *步* 或 *动作块* 有关联。如果至少一个关联是激活的，则`ACTION_CONTROL`的该布尔输入的值为`TRUE`。
3. `ACTION_CONTROL`的`T`输入的值应为一个活动关联的时间相关限定符（`L`,`D`,`SD`,`DS`,`SL`）的时间部分的值。
4. 以下的情况将被视为 **错误**
    * 一个动作有多个活动关联具有时间相关限定符。
    * 当`ACTION_CONTROL`的`SL_FF`的`Q1`输出值为`TRUE`时，`SD`输入值为`TRUE`。
    * 当`ACTION_CONTROL`的`SD_FF`的`Q1`输出值为`TRUE`时，`SL`输入值为`TRUE`。
5. `ACTION_CONTROL`本身不要求实现，只要动作控制等效于以上规则。

`ACTION_CONTROL`功能块（不带“最后扫描”逻辑）-外部接口：

```
       +----------------+
       | ACTION_CONTROL |
BOOL---|N              Q|---BOOL 
BOOL---|R               |
BOOL---|S               | 
BOOL---|L               | 
BOOL---|D               | 
BOOL---|P               |
BOOL---|P1              | 
BOOL---|P0              | 
BOOL---|SD              | 
BOOL---|DS              | 
BOOL---|SL              | 
TIME---|T               |
       +----------------+
```

### 演化规则

SFC网络的 **初始状态** 表征为 *程序* 或 *功能块* 初始化时处于激活状态的 *初始步* 。激活步在 *转换* 发生时沿着 *有向连接* 进行 **演化** 。

当前面的步都处于激活状态时， *转换* 处于激活状态。当 *转换* 处于激活状态并且转换条件为`TRUE`时转换发生。转换发生后，前面步的状态被重置，而后面的步被激活。

如果一次状态转移导致多个步的激活，那么这些步所属序列成为 *并发序列* 。同时被激活后，他们的演化将相互独立。

当步的激活已经传播至声明该步的整个程序组织单元后，对于激活步的测试和后面的转换才可以发生。

> 状态转移时间理论上被视为无限短，而实际上不可能为零，该时间应被PC实现限制。
> 同时激活步的“发散”和“收敛”构造的最大宽度是 **实现相关** 的。

示例：

```
  | 
+----+
| S5 |
+----+ 
  |
  +------+----+--...
  |      |
  +e     +NOT e & f
  |      |
+----+ +----+
| S6 | | S8 |
+----+ +----+
  |      |
```

5到6的转换发生条件：5为激活状态，且e为`TRUE`；
5到8的转换发生条件：5为激活状态，且e为`FALSE`，且f为`TRUE`；

状态转移步骤示例：

转换未激活（`X=0 or 1`）：

```
    |          |       |        | 
+------+    +-----+ +------+ +------+ 
|STEP10|    |STEP9| |STEP13| |STEP22| 
|      |    |     | |  *   | |  *   |
+------+    +-----+ +------+ +------+   
    |          |       |        |
    + X    ====+=======+========+==== 
    |                  |
+------+               +X
|STEP11|               |
|      |      ====+====+===+====
+------+          |        |
    |         +------+  +------+  
              |STEP15|  |STEP16| 
              |      |  |      |
              +------+  +------+ 
                  |        |
```

转换激活，但未发生（`X=0`）：

```
    |          |       |        | 
+------+    +-----+ +------+ +------+ 
|STEP10|    |STEP9| |STEP13| |STEP22| 
|  *   |    |  *  | |  *   | |  *   |
+------+    +-----+ +------+ +------+   
    |          |       |        |
    + X    ====+=======+========+==== 
    |                  |
+------+               +X
|STEP11|               |
|      |      ====+====+===+====
+------+          |        |
    |         +------+  +------+  
              |STEP15|  |STEP16| 
              |      |  |      |
              +------+  +------+ 
                  |        |
```

转换发生（`X=1`）：

```
    |          |       |        | 
+------+    +-----+ +------+ +------+ 
|STEP10|    |STEP9| |STEP13| |STEP22| 
|      |    |     | |      | |      |
+------+    +-----+ +------+ +------+   
    |          |       |        |
    + X    ====+=======+========+==== 
    |                  |
+------+               +X
|STEP11|               |
|  *   |      ====+====+===+====
+------+          |        |
    |         +------+  +------+  
              |STEP15|  |STEP16| 
              |   *  |  |  *   |
              +------+  +------+ 
                  |        |
```

## 配置元素

**配置** 包含 *资源* ， *任务* （在 *资源* 中定义）， *全局变量* ， *访问路径* 和实例初始化。下图为一个简单配置的图形示例：

![](/assets/img/blog/configuration-example.png)

*功能块* 和 *程序* 的纲要声明如下：

![](/assets/img/blog/configuration-example-st.png) 

### 配置，资源和访问路径

下表列举了声明配置、资源、全局变量、访问路径，以及实例化的特性。

编号 | 说明 
---  | --- 
1 | `CONFIGURATION...END_CONFIGURATION` 构造
2 |  定义在`CONFIGURATION`中的`VAR_GLOBAL...END_VAR`构造 
3 | `RESOURCE...ON...END_RESOURCE` 构造
4 | 定义在`RESOURCE`中的`VAR_GLOBAL...END_VAR`构造
5a | 周期性的`TASK`构造
5b | 非周期性的`TASK`构造
6a | 关联`PROGRAM`与`TASK`的`WITH`构造
6b | 关联功能块与`TASK`的`WITH`构造
6c | 没有`TASK`关联的`PROGRAM`声明
7 | `VAR_GLOBAL`中声明的直接表示变量
8a | 直接表示变量与`PROGRAM`输入的连接
8b | `GLOBAL`变量与`PROGRAM`输入的连接
9a | `PROGRAM`输出与直接表示变量的连接
9b | `PROGRAM`输出与`GLOBAL`变量的连接
10a | `VAR_ACCESS...END_VAR`构造
10b | 直接表示变量的访问路径
10c | `PROGRAM`输入的访问路径
10d | `RESOURCE`中`GLOBAL`变量的访问路径
10e | `CONFIGURATION`中`GLOBAL`变量的访问路径
10f | `PROGRAM`输出的访问路径
10g | `PROGRAM`内部变量的访问路径
10h | 功能块输入的访问路径
10i | 功能块输出的访问路径
11 | `VAR_CONFIG...END_VAR`构造
12a | `RESOURCE`声明中的`VAR_GLOBAL CONSTANT`
12b | `CONFIGURATION`声明中的`VAR_GLOBAL CONSTANT`
13a | `RESOURCE`声明中的`VAR_EXTERNAL`
13b | `RESOURCE`声明中的`VAR_EXTERNAL CONSTANT`

* 在`RESOURCE...ON...END_RESOURCE`中的`ON`限定符用来指定处理功能及其人机接口、传感器-执行器接口的类型。
* `VAR_GLOBAL`的作用域限于声明它的 *配置* 或 *资源* 。
* `VAR_ACCESS`用于远程访问（IEC 61131-5），可以关联的变量有：全局变量、直接表示变量、任何 *程序* 和 *功能块* 的输入、输出、内部变量。
* `VAR_CONFIG...END_VAR`构造用于初始化符号表示的变量和位置未确定的（`*`表示）直接表示变量。

> `VAR_ACCESS`的关联需要指出变量所处的完整层级；对于下列变量不可定义访问路径：`VAR_TEMP`,`VAR_EXTERNAL`,`VAR_IN_OUT`；访问路径可指定方向：`READ_WRITE`,`READ_ONLY`(默认)。
> `VAR_CONFIG`不可对下列类型的实例初始化：`VAR_TEMP`,`VAR_EXTERNAL`,`VAR CONSTANT`,`VAR_IN_OUT`。

下图给出了上述特性的示例：

```
CONFIGURATION CELL_1

    VAR_GLOBAL w: UINT; END_VAR 

    RESOURCE STATION_1 ON PROCESSOR_TYPE_1
        VAR_GLOBAL z1: BYTE; END_VAR 
        TASK SLOW_1(INTERVAL := t#20ms, PRIORITY := 2) ; 
        TASK FAST_1(INTERVAL := t#10ms, PRIORITY := 1) ;
        PROGRAM P1 WITH SLOW_1 :
            F(x1 := %IX1.1) ; 
        PROGRAM P2 : G(OUT1 => w,
            FB1 WITH SLOW_1, 
            FB2 WITH FAST_1) ;
    END_RESOURCE

    RESOURCE STATION_2 ON PROCESSOR_TYPE_2
        VAR_GLOBAL z2   : BOOL ;
            AT %QW5     : INT ;
        END_VAR
        TASK PER_2(INTERVAL := t#50ms, PRIORITY := 2) ;
        TASK INT_2(SINGLE := z2, PRIORITY := 1);
        PROGRAM P1 WITH PER_2 :
            F(x1:=z2,x2:=w) ; 
        PROGRAM P4 WITH INT_2 :
            H(HOUT1 => %QW5, 
                FB1 WITH PER_2);
    END_RESOURCE

    VAR_ACCESS
        ABLE    : STATION_1.%IX1.1  : BOOL READ_ONLY ;
        BAKER   : STATION_1.P1.x2   : UINT READ_WRITE ;
        CHARLIE : STATION_1.z1      : BYTE ;
        DOG     : w                 : UINT READ_ONLY ;
        ALPHA   : STATION_2.P1.y1   : BYTE READ_ONLY ;
        BETA    : STATION_2.P4.HOUT1: INT READ_ONLY ;
        GAMMA   : STATION_2.z2      : BOOL READ_WRITE ;
        S1_COUNT: STATION_1.P1.COUNT  : INT;
        THETA   : STATION_2.P4.FB2.d1 : BOOL READ_WRITE; 
        ZETA    : STATION_2.P4.FB1.c1 : BOOL READ_ONLY; 
        OMEGA   : STATION_2.P4.FB1.C3 : INT READ_WRITE;
    END_VAR

    VAR_CONFIG
        STATION_1.P1.COUNT : INT := 1; 
        STATION_2.P1.COUNT : INT := 100; 
        STATION_1.P1.TIME1 : TON := (PT := T#2.5s); 
        STATION_2.P1.TIME1 : TON := (PT := T#4.5s); 
        STATION_2.P4.FB1.C2 AT %QB25 : BYTE;
    END_VAR

END_CONFIGURATION
```

### 任务

**任务** 是可以调用一个程序组织单元集合的执行控制元素。可以是周期性地调用，也可以是当指定布尔变量上升沿发生时调用。

> 每个 *资源* 可以拥有任务的上限和任务执行间隔的精度是 **实现相关** 的。

任务对程序执行单元的控制应满足下列规则：

1. 关联的程序组织单元应在任务的`SINGLE`输入的每个上升沿被调度。
2. 当`INTERVAL`输入非零，关联的程序组织单元应被周期性调度，直到`SINGLE`非零。
3. `PRIORITY`输入建立了相关联的程序组织单元的优先级，用于抢占式和非抢占式调度。
4. 没有与`TASK`关联的`program`拥有最低的系统优先级。
5. 当 *功能块* 与 *任务* 关联后，其执行应受该任务的独有控制，而与其声明所在的程序组织单元无关。
6. 没有直接与 *任务* 关联的程序组织单元应遵循程序组织单元的语言元素的正常求值顺序。
7. 同一 *程序* 内功能块的执行应被同步，以保证并发的数据一致性。

任务的图形表示

```
         TASKNAME
       +---------+ 
       |  TASK   |
BOOL---|SINGLE   | 
TIME---|INTERVAL | 
UINT---|PRIORITY |
       +---------+

(* 周期任务 *)
           SLOW_1               FAST_1 
         +---------+          +---------+ 
         |  TASK   |          |  TASK   | 
         |SINGLE   |          |SINGLE   | 
t#20ms---|INTERVAL | t#10ms---|INTERVAL | 
     2---|PRIORITY |      1---|PRIORITY | 
         +---------+          +---------+
```

# 文本语言

该标准定义的文本语言包括IL语言和ST语言，SFC元素可以用于这些语言之间的连接。

## 共同元素

第二部分已经给出了文本语言的共同部分。如下具体列出文本语言中共同的程序结构元素：

```
TYPE...END_TYPE             VAR...END_VAR
VAR_INPUT...END_VAR         VAR_OUTPUT...END_VAR 
VAR_IN_OUT...END_VAR        VAR_EXTERNAL...END_VAR 
VAR_TEMP...END_VAR          VAR_ACCESS...END_VAR 
VAR_GLOBAL...END_VAR        VAR_CONFIG...END_VAR
FUNCTION ... END_FUNCTION   FUNCTION_BLOCK...END_FUNCTION_BLOCK 
PROGRAM...END_PROGRAM       STEP...END_STEP 
TRANSITION...END_TRANSITION ACTION...END_ACTION
```

## IL语言

IL语言的形式化语法定义在附录B中，这里介绍IL语言的语义。

### 指令

IL（instruction list）由指令（instruction）序列组成。每个指令另起一行，包含操作符、可选的限定符、逗号分隔的不少于一个的操作数。指令可以前加一个标签和`:`来标识，指令间的空行是允许的。

> 操作数可以是直接量、枚举值、变量。

### 操作符、限定符、操作数

一般地，操作符的语义表示为：

```
result := result OP operand
```

> 以`N`结尾的操作符表示操作数取反码。类型不匹配和溢出都会被视为 **错误** 。

左括号`(`表示操作符的求值将被一直延迟到`)`出现为止。

### 功能和功能块

可以通过把功能名放在操作符的域来进行功能调用。功能调用有通过形参调用和直接写实参两种形式，参数间用`,`分隔。可以通过`RET`指令得到返回值。

功能块的调用可以通过`CAL`操作符，操作数为功能块的实例名。功能调用的规则和特性同样适用于功能块调用。

## ST语言

这部分定义了ST语言的语义，其语法定义在附录B3中。

### 表达式

*表达式* 是一个语言构造，求值后，将产生一个对应这某种数据类型的值。表达式的最大长度是 **实现相关** 的。

表达式由 *操作符* 和 *操作数* 组成，ST语言的操作符见下表；操作数可以是直接量、枚举值、变量、功能调用、或者另一个表达式。功能通过功能名和括号内的参数列表来调用。

编号    | 操作      | 符号              | 优先级
---     | ---       | ---               | ---
1       | 括号      | (表达式)          | 最高
2       | 功能求值  | 标识符(参数列表)  |
4       | 取负      |   `-`             |
5       | 取反      | `NOT`             |
3       | 指数      | `**`              |
6       | 乘        | `*`               |
7       | 除        | `/`               |
8       | 模        | `MOD`             |
9       | 加        | `+`               |
10      | 减        | `-`               |
11      | 比较      | `>,<.>=,<=`       |
12      | 相等      | `=`               |
13      | 不等      |  `<>`             |
14      | 布尔与    | `&`               |
15      | 布尔与    | `AND`             |
16      | 布尔异或  | `XOR`             |
17      | 布尔或    | `OR`              | 最低

表达式中，高优先级的运算符总是先求值，同样优先级的从左到右求值。当一个操作符有两个操作数时，左侧的操作数总是被先求值。

### 语句

ST语言的语句以`;`结尾，其语法见附录B3。语句的最大长度是 **实现相关** 的。ST语言的语句有10种：赋值、功能块调用、`return`、`if`、`case`、`for`、`while`、`repeat`、`exit`、空语句。

**赋值语句** 将当期变量的值替换为表达式的值，包括三部分：变量名、`:=`、表达式。同时，赋值语句可以用来赋功能的返回值，此时用功能名代替变量名。

**功能和功能块控制语句** 包括调用功能或功能块的机制和调用结束后控制返回调用处的机制。对功能块的调用可以通过实例名加括号内的参数列表。`RETURN`语句提供了提前结束功能、功能块、程序的机制。

**选择语句** 包括`if`和`case`，根据指定的条件选择一部分继续执行。允许选择的数目是 **实现相关** 的。

**迭代语句** 包括`WHILE`,`REPEAT`和`FOR`。后者用于迭代次数已知的情况。迭代语句中出现`EXIT`时，最内层循环将被结束。`FOR`可以在迭代中对控制变量递增或递减，循环结束后控制变量的值是 **实现相关** 的。


# 图形语言

该标准中定义的图形语言包括LD语言和FBD语言，SFC元素可用于它们之间的连接。

## 共同元素

这里定义了LD、FBD、SFC的共同元素。图形语言元素使用的字符集在第二章给出了定义，使用的图形和半图形元素定义在IOS/IEC 10646-1。并且线可以通过 *连接符* 扩展。

**网络** 被定义为互相连接的图形元素（不包括LD语言中的左右电源墙）的最大集合。网络可以用标识符或十进制无符号整数加`:`标识，网络与其标签的作用域对其所在程序组织单元应是局部的。

图形语言用来描述概念量在表示控制计划的网络中的流动：

* 功率流：类似继电系统中的电流，用于LD语言中，流向为从左到右；
* 信号流：类似信号处理系统元素间的信号流，用于FBD语言中，流向为一个元素的输出到另一元素的输入。
* 活动流：类似控制流在组织或机电定序器的步骤之间的流动，用于SFC中，流向为从一个步的底部经过合适的转换到后续步的顶部。

**网络求值顺序** 不一定与其标记或显示顺序相同。同样地，一个网络求值能被重复前，不必对所有网络进行求值。然而，当一个程序组织单元体包含一个或多个网络时，该程序组织单元体网络求值的结果应功能上等价于以下规则：

1. 当一个网络元素的所有输入求值后，该网络元素才能求值。
2. 一个网络元素的所有输出求值后，该网络元素才能结束求值。
3. 当网络的所有元素求值结束后，该网络才能结束求值。
4. 网络求值顺序应符合LD和FBD语言中的规定。

当一个功能或功能块的输出被用于网络中处于它前面的功能或功能块的输入，就称该网络存在 **回路** ，与之关联的变量称为 **反馈变量** 。回路的使用应满足如下规则：

1. 显式的回路只能出现在FBD语言中。
2. 用户应能够使用 **实现相关** 的方式来决定在显式回路中元素的执行顺序。
3. 反馈变量可以使用第二部分定义的机制来初始化，初始值将被用于第一次网络求值。
4. 一旦将反馈变量作为输出的元素被求值，新的反馈变量将被使用，直到该元素的下一次求值。

LD和FBD语言中，提供了很多 **控制转移** 机制。跳转表示为从布尔变量开始的以双箭头结束的信号线，该变量即为跳转条件（如果为直接量`TRUE`则表示无条件跳转），跳转的目标应为当前程序组织单元中的网络标签。功能和功能块中的有条件返回应使用`RETURN`关键字。

```
        +---+ 
%IX20---| & |--->>NEXT
%MX50---|   |
        +---+
NEXT:
        +---+
%IX25---|>=1|---%QX100 
%MX60---|   |
        +---+
```

## LD语言

LD程序使得可编程控制器可以使用标准化的图形符号测试和修改数据。这些符号表现为类似继电逻辑电路中的横档构成的网络。LD网络左右都用 **电源墙** 作为边界：

```
|
+---    (* 左电源墙 *)
|
   |
---+    (* 右电源墙 *)
   |
```

**连接** 元素表示这`ON`或`OFF`，分别对应于布尔值`1`或`0`。 *连接状态* 是 *功率流* 的同义词。左电源墙的状态始终为`ON`，右电源墙的状态没有定义。

水平的连接表示为水平线，它将紧邻的左侧元素状态传递给紧邻的右侧元素。垂直的连接表示为垂直线，将左侧紧邻元素的状态取`OR`后传递给右侧紧邻元素。

```
----------  (* 水平连接 *)

    |
----+----
----+       (* 垂直连接 *)
    |  
    +----
```

**触点** 有条件地将左侧水平连接的状态传递到右侧，等效于将左侧状态与某个功能取`AND`后传递到右侧。包括：常开触点、常闭出点、正转换检测触点、负转换检测触点。

**线圈** 将左侧水平连接状态复制到右侧水平连接，并将以左侧状态为参数的某个功能的值存储入与之关联的布尔变量。

```
|   a    b       c     d   |
+--( )--| |--+--( )---( )--+
|            |      e      |
|            +-----( )-----+
|                          |
```

功能和功能块的表示在第二部分已有定义，此外有如下特殊情况：

1. 实参连接是可选的，在块外侧挨着形参的地方写合适的数据或者变量。
2. 至少一个布尔输入和至少一个布尔输出必须显示在每个块上，以允许功率流通过该块。

在LD语言表示的程序组织单元中，通过自上而下的顺序进行网络求值，除非该顺序被执行控制元素修改。

## FBD语言

该部分定义FBD语言，用于可编程控制器的图形编程语言。该语言应尽量与 IEC 60617-12 保持一致，冲突的部分应使用本标准。

第二部分和第四部分第一节规定的共同元素适用于FBD语言的可编程控制器程序的构造和解释。FBD语言使用示例见附录F。

FBD语言元素应使用信号线互相连接，功能块的输出不能被连接在一起。特别地，LD语言中直接相连的`OR`结构在FBD语言中是不允许的，应显式地使用`OR`块：

```
|   a      c   |        +-----+
+---||--+--()--+    a---| >=1 |---c
|  b    |      |    b---|     |
+--||---+      |        +-----+
|              |
(* LD语言OR *)      (* FBD语言OR *)
```

当FBD语言的程序组织单元包含多于一个网络时，制造商应提供 **实现相关** 方法来让用户能够决定网络求值顺序。
